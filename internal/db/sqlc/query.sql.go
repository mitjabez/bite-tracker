// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createMeal = `-- name: CreateMeal :one
INSERT INTO meals (
  user_id,
  meal_type_id,
  time_of_meal,
  description,
  hunger_level,
  symptoms
) VALUES (
  $1,$2,$3,$4,$5,$6
)
RETURNING id, user_id, meal_type_id, time_of_meal, description, hunger_level, symptoms, created_at, updated_at
`

type CreateMealParams struct {
	UserID      uuid.UUID
	MealTypeID  string
	TimeOfMeal  time.Time
	Description string
	HungerLevel int32
	Symptoms    []string
}

func (q *Queries) CreateMeal(ctx context.Context, arg CreateMealParams) (Meal, error) {
	row := q.db.QueryRow(ctx, createMeal,
		arg.UserID,
		arg.MealTypeID,
		arg.TimeOfMeal,
		arg.Description,
		arg.HungerLevel,
		arg.Symptoms,
	)
	var i Meal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MealTypeID,
		&i.TimeOfMeal,
		&i.Description,
		&i.HungerLevel,
		&i.Symptoms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, full_name, password_hash)
VALUES ($1, $2, $3)
RETURNING id, email, full_name, password_hash, created_at, updated_at
`

type CreateUserParams struct {
	Email        string
	FullName     string
	PasswordHash *string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.FullName, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMeal = `-- name: GetMeal :one
SELECT id, user_id, meal_type_id, time_of_meal, description, hunger_level, symptoms, created_at, updated_at FROM meals
WHERE id = $1
`

func (q *Queries) GetMeal(ctx context.Context, id uuid.UUID) (Meal, error) {
	row := q.db.QueryRow(ctx, getMeal, id)
	var i Meal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MealTypeID,
		&i.TimeOfMeal,
		&i.Description,
		&i.HungerLevel,
		&i.Symptoms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, full_name, password_hash, created_at, updated_at FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, full_name, password_hash, created_at, updated_at FROM users
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMealsByUsernameAndDate = `-- name: ListMealsByUsernameAndDate :many
SELECT id, user_id, meal_type_id, time_of_meal, description, hunger_level, symptoms, created_at, updated_at FROM meals
WHERE user_id = $1 AND
	time_of_meal > $2 AND time_of_meal < ( ($2) + interval '1 day' )
ORDER BY time_of_meal
`

type ListMealsByUsernameAndDateParams struct {
	UserID  uuid.UUID
	ForDate time.Time
}

func (q *Queries) ListMealsByUsernameAndDate(ctx context.Context, arg ListMealsByUsernameAndDateParams) ([]Meal, error) {
	rows, err := q.db.Query(ctx, listMealsByUsernameAndDate, arg.UserID, arg.ForDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MealTypeID,
			&i.TimeOfMeal,
			&i.Description,
			&i.HungerLevel,
			&i.Symptoms,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const top3Meals = `-- name: Top3Meals :many
SELECT description, times_used FROM meals_catalog
WHERE user_id = $1 AND meal_type_id = $2
ORDER BY times_used DESC
LIMIT 3
`

type Top3MealsParams struct {
	UserID     uuid.UUID
	MealTypeID string
}

type Top3MealsRow struct {
	Description string
	TimesUsed   int32
}

func (q *Queries) Top3Meals(ctx context.Context, arg Top3MealsParams) ([]Top3MealsRow, error) {
	rows, err := q.db.Query(ctx, top3Meals, arg.UserID, arg.MealTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Top3MealsRow
	for rows.Next() {
		var i Top3MealsRow
		if err := rows.Scan(&i.Description, &i.TimesUsed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMeal = `-- name: UpdateMeal :exec
UPDATE meals
  SET meal_type_id = $2,
  time_of_meal = $3,
  description = $4,
  hunger_level = $5,
  symptoms = $6,
  updated_at = $7
WHERE id = $1
`

type UpdateMealParams struct {
	ID          uuid.UUID
	MealTypeID  string
	TimeOfMeal  time.Time
	Description string
	HungerLevel int32
	Symptoms    []string
	UpdatedAt   time.Time
}

func (q *Queries) UpdateMeal(ctx context.Context, arg UpdateMealParams) error {
	_, err := q.db.Exec(ctx, updateMeal,
		arg.ID,
		arg.MealTypeID,
		arg.TimeOfMeal,
		arg.Description,
		arg.HungerLevel,
		arg.Symptoms,
		arg.UpdatedAt,
	)
	return err
}

const updateMealsCatalog = `-- name: UpdateMealsCatalog :exec
INSERT INTO meals_catalog (
	user_id,
	description,
  meal_type_id
) VALUES (
	$1,
	$2,
	$3
) ON CONFLICT(user_id, description, meal_type_id) DO UPDATE
SET times_used = meals_catalog.times_used + 1
`

type UpdateMealsCatalogParams struct {
	UserID      uuid.UUID
	Description string
	MealTypeID  string
}

func (q *Queries) UpdateMealsCatalog(ctx context.Context, arg UpdateMealsCatalogParams) error {
	_, err := q.db.Exec(ctx, updateMealsCatalog, arg.UserID, arg.Description, arg.MealTypeID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
  SET email = $1,
  full_name = $2,
  password_hash = $3
WHERE id = $4
`

type UpdateUserParams struct {
	Email        string
	FullName     string
	PasswordHash *string
	ID           uuid.UUID
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.Email,
		arg.FullName,
		arg.PasswordHash,
		arg.ID,
	)
	return err
}
