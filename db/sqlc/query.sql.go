// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMeal = `-- name: CreateMeal :one
INSERT INTO meals (
  user_id,
  meal_type,
  time_of_meal,
  description,
  hunger_level,
  symptoms
) VALUES (
  $1,$2,$3,$4,$5,$6
)
RETURNING id, user_id, meal_type, time_of_meal, description, hunger_level, symptoms, created_at, updated_at
`

type CreateMealParams struct {
	UserID      pgtype.UUID
	MealType    string
	TimeOfMeal  time.Time
	Description string
	HungerLevel int32
	Symptoms    []string
}

func (q *Queries) CreateMeal(ctx context.Context, arg CreateMealParams) (Meal, error) {
	row := q.db.QueryRow(ctx, createMeal,
		arg.UserID,
		arg.MealType,
		arg.TimeOfMeal,
		arg.Description,
		arg.HungerLevel,
		arg.Symptoms,
	)
	var i Meal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MealType,
		&i.TimeOfMeal,
		&i.Description,
		&i.HungerLevel,
		&i.Symptoms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMealsByUsernameAndDate = `-- name: ListMealsByUsernameAndDate :many
SELECT m.id, m.user_id, m.meal_type, m.time_of_meal, m.description, m.hunger_level, m.symptoms, m.created_at, m.updated_at FROM meals m
JOIN users u ON m.user_id = u.id
WHERE u.username = $1 AND
	time_of_meal > $2::timestamp AND time_of_meal < ( ($2::timestamp) + interval '1 day' )
ORDER BY time_of_meal
`

type ListMealsByUsernameAndDateParams struct {
	Username pgtype.Text
	ForDate  time.Time
}

func (q *Queries) ListMealsByUsernameAndDate(ctx context.Context, arg ListMealsByUsernameAndDateParams) ([]Meal, error) {
	rows, err := q.db.Query(ctx, listMealsByUsernameAndDate, arg.Username, arg.ForDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MealType,
			&i.TimeOfMeal,
			&i.Description,
			&i.HungerLevel,
			&i.Symptoms,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMeal = `-- name: UpdateMeal :exec
UPDATE meals
  SET meal_type = $2,
  time_of_meal = $3,
  description = $4,
  hunger_level = $5,
  symptoms = $6,
  updated_at = $7
WHERE id = $1
`

type UpdateMealParams struct {
	ID          uuid.UUID
	MealType    string
	TimeOfMeal  time.Time
	Description string
	HungerLevel int32
	Symptoms    []string
	UpdatedAt   time.Time
}

func (q *Queries) UpdateMeal(ctx context.Context, arg UpdateMealParams) error {
	_, err := q.db.Exec(ctx, updateMeal,
		arg.ID,
		arg.MealType,
		arg.TimeOfMeal,
		arg.Description,
		arg.HungerLevel,
		arg.Symptoms,
		arg.UpdatedAt,
	)
	return err
}
